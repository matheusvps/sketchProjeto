{"ast":null,"code":"import _slicedToArray from \"C:/Users/rodri/sketchProjeto/view/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { isDeepEqual } from '../utils/is.js';\nvar defaultCfg = {\n  threshold: 0,\n  root: null,\n  rootMargin: '0px'\n};\nfunction _update(el, ctx, value) {\n  var handler, cfg, changed;\n  if (typeof value === 'function') {\n    handler = value;\n    cfg = defaultCfg;\n    changed = ctx.cfg === void 0;\n  } else {\n    handler = value.handler;\n    cfg = Object.assign({}, defaultCfg, value.cfg);\n    changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false;\n  }\n  if (ctx.handler !== handler) {\n    ctx.handler = handler;\n  }\n  if (changed === true) {\n    ctx.cfg = cfg;\n    ctx.observer !== void 0 && ctx.observer.unobserve(el);\n    ctx.observer = new IntersectionObserver(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 1),\n        entry = _ref2[0];\n      if (typeof ctx.handler === 'function') {\n        // if observed element is part of a vue transition\n        // then we need to be careful...\n        if (entry.rootBounds === null && (el.__vue__ !== void 0 ? el.__vue__._inactive !== true : document.body.contains(el) === true)) {\n          ctx.observer.unobserve(el);\n          ctx.observer.observe(el);\n          return;\n        }\n        var res = ctx.handler(entry, ctx.observer);\n        if (res === false || ctx.once === true && entry.isIntersecting === true) {\n          destroy(el);\n        }\n      }\n    }, cfg);\n    ctx.observer.observe(el);\n  }\n}\nfunction destroy(el) {\n  var ctx = el.__qvisible;\n  if (ctx !== void 0) {\n    ctx.observer !== void 0 && ctx.observer.unobserve(el);\n    delete el.__qvisible;\n  }\n}\nexport default {\n  name: 'intersection',\n  inserted: function inserted(el, _ref3) {\n    var modifiers = _ref3.modifiers,\n      value = _ref3.value;\n    if (el.__qvisible !== void 0) {\n      destroy(el);\n      el.__qvisible_destroyed = true;\n    }\n    var ctx = {\n      once: modifiers.once === true\n    };\n    _update(el, ctx, value);\n    el.__qvisible = ctx;\n  },\n  update: function update(el, binding) {\n    var ctx = el.__qvisible;\n    ctx !== void 0 && _update(el, ctx, binding.value);\n  },\n  unbind: function unbind(el) {\n    if (el.__qvisible_destroyed === void 0) {\n      destroy(el);\n    } else {\n      delete el.__qvisible_destroyed;\n    }\n  }\n};","map":{"version":3,"names":["isDeepEqual","defaultCfg","threshold","root","rootMargin","update","el","ctx","value","handler","cfg","changed","Object","assign","observer","unobserve","IntersectionObserver","_ref","_ref2","_slicedToArray","entry","rootBounds","__vue__","_inactive","document","body","contains","observe","res","once","isIntersecting","destroy","__qvisible","name","inserted","_ref3","modifiers","__qvisible_destroyed","binding","unbind"],"sources":["C:/Users/rodri/sketchProjeto/view/node_modules/quasar/src/directives/Intersection.js"],"sourcesContent":["import { isDeepEqual } from '../utils/is.js'\n\nconst defaultCfg = {\n  threshold: 0,\n  root: null,\n  rootMargin: '0px'\n}\n\nfunction update (el, ctx, value) {\n  let handler, cfg, changed\n\n  if (typeof value === 'function') {\n    handler = value\n    cfg = defaultCfg\n    changed = ctx.cfg === void 0\n  }\n  else {\n    handler = value.handler\n    cfg = Object.assign({}, defaultCfg, value.cfg)\n    changed = ctx.cfg === void 0 || isDeepEqual(ctx.cfg, cfg) === false\n  }\n\n  if (ctx.handler !== handler) {\n    ctx.handler = handler\n  }\n\n  if (changed === true) {\n    ctx.cfg = cfg\n    ctx.observer !== void 0 && ctx.observer.unobserve(el)\n\n    ctx.observer = new IntersectionObserver(([ entry ]) => {\n      if (typeof ctx.handler === 'function') {\n        // if observed element is part of a vue transition\n        // then we need to be careful...\n        if (\n          entry.rootBounds === null &&\n          (el.__vue__ !== void 0 ? el.__vue__._inactive !== true : document.body.contains(el) === true)\n        ) {\n          ctx.observer.unobserve(el)\n          ctx.observer.observe(el)\n          return\n        }\n\n        const res = ctx.handler(entry, ctx.observer)\n\n        if (\n          res === false ||\n          (ctx.once === true && entry.isIntersecting === true)\n        ) {\n          destroy(el)\n        }\n      }\n    }, cfg)\n\n    ctx.observer.observe(el)\n  }\n}\n\nfunction destroy (el) {\n  const ctx = el.__qvisible\n\n  if (ctx !== void 0) {\n    ctx.observer !== void 0 && ctx.observer.unobserve(el)\n    delete el.__qvisible\n  }\n}\n\nexport default {\n  name: 'intersection',\n\n  inserted (el, { modifiers, value }) {\n    if (el.__qvisible !== void 0) {\n      destroy(el)\n      el.__qvisible_destroyed = true\n    }\n\n    const ctx = {\n      once: modifiers.once === true\n    }\n\n    update(el, ctx, value)\n\n    el.__qvisible = ctx\n  },\n\n  update (el, binding) {\n    const ctx = el.__qvisible\n    ctx !== void 0 && update(el, ctx, binding.value)\n  },\n\n  unbind (el) {\n    if (el.__qvisible_destroyed === void 0) {\n      destroy(el)\n    }\n    else {\n      delete el.__qvisible_destroyed\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}